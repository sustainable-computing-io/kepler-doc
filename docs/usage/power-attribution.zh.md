```markdown
# 理解Kepler功耗归因机制

本指南将解释Kepler如何测量系统上运行的进程、容器、虚拟机和Pod的功耗并进行归因。

## 功耗归因原理

### 整体框架

现代系统缺乏针对单个工作负载的能耗计量能力，仅能提供硬件层面的总功耗数据。Kepler通过基于资源利用率的比例分配来解决这一归因难题：

1. **硬件能耗采集** - 通过Intel RAPL传感器获取封装、核心、内存及非核心组件的累积能耗计数
2. **系统活动分析** - 从`/proc/stat`获取CPU利用率指标，确定系统活跃与空闲运行的比例
3. **功耗域分离** - 将总能耗拆分为活跃功耗（与工作负载活动成正比）和空闲功耗（基础消耗）
4. **比例归因** - 根据工作负载的CPU时间占比分配活跃功耗

### 核心原则

Kepler采用**基于CPU时间的能耗归因模型**，根据工作负载的计算资源使用模式将硬件测量的能耗分配到个体工作负载。

其基本原理是将系统功耗划分为两个独立部分：

- **活跃功耗**：用于计算工作的能耗，与CPU利用率成正比并随工作负载活动扩展
- **空闲功耗**：维持系统运行的固定基础能耗，包括内存刷新、时钟分发和空闲核心电源状态

### 归因公式

所有工作负载类型使用相同的比例归因公式：

```text
工作负载功耗 = (工作负载CPU时间增量 Δ / 节点CPU时间增量 Δ) × 活跃功耗
```

该公式确保能耗守恒——归因功耗总和与测量的硬件消耗保持比例关系，同时基于实际资源利用率维持公平性。

![功耗归因示意图](assets/power-attribution.png)

*图1：功耗归因流程展示总测量功耗如何分解为活跃与空闲组件，其中活跃功耗基于工作负载CPU时间增量按比例分配*

## 理解能量与功率

- **能量**：以微焦耳(μJ)为单位，来自硬件的累积计数器
- **功率**：以微瓦(μW)为单位的速率，通过`功率 = Δ能量/Δ时间`计算

## 能量区域

硬件能量从不同区域读取：

- **封装( Package )**：CPU封装级能耗
- **核心( Core )**：单个CPU核心能耗
- **内存( DRAM )**：内存子系统能耗
- **非核心( Uncore )**：集成显卡及其他非核心组件
- **平台级( PSys )**：最全面的平台级能耗（当可用时）

## 归因示例

### 示例1：基础功耗拆分

**系统状态：**
- 硬件报告：40W总系统功耗
- 节点CPU使用率：25%
- 功耗拆分：40W × 25% = 10W活跃，30W空闲

**工作负载归因：**
若某容器在测量周期内消耗了20%的节点CPU时间：
- **容器功耗** = (20% CPU使用率) × 10W活跃 = 2W

### 示例2：多工作负载场景

**系统状态：**
- 总功耗：60W
- CPU使用率：33.3%（1/3）
- 活跃功耗：20W，空闲功耗：40W
- 节点总CPU时间：1000ms

**进程级CPU使用：**
- 进程1（独立）：100ms CPU时间
- 进程2（容器A内）：80ms CPU时间
- 进程3（容器A内）：70ms CPU时间
- 进程4（容器B内）：60ms CPU时间
- 进程5（QEMU虚拟机）：200ms CPU时间
- 进程6（容器C内，Pod X）：90ms CPU时间
- 进程7（容器D内，Pod X）：110ms CPU时间

**层级化CPU时间聚合：**
- 容器A CPU时间：80ms + 70ms = 150ms
- 容器B CPU时间：60ms
- 容器C CPU时间：90ms（属于Pod X）
- 容器D CPU时间：110ms（属于Pod X）
- Pod X CPU时间：90ms + 110ms = 200ms
- 虚拟机CPU时间：200ms（QEMU管理进程）

**独立功耗归因（均来自节点活跃功耗）：**
- 进程1：(100ms / 1000ms) × 20W = 2W
- 容器A：(150ms / 1000ms) × 20W = 3W
- 容器B：(60ms / 1000ms) × 20W = 1.2W
- Pod X：(200ms / 1000ms) × 20W = 4W
- 虚拟机：(200ms / 1000ms) × 20W = 4W

**注：** 每种工作负载类型基于自身CPU时间从节点活跃功耗独立计算，而非继承自组成工作负载。

### 示例3：多进程容器

**容器"web-server"：**
- 进程1（nginx）：100ms CPU时间
- 进程2（worker）：50ms CPU时间
- 容器总计：150ms CPU时间

**若节点总CPU时间为1000ms：**
- 容器CPU占比：150ms / 1000ms = 15%
- 容器功耗：15% × 活跃功耗

### 示例4：多容器Pod

**Pod "frontend"：**
- 容器1（nginx）：200ms CPU时间
- 容器2（sidecar）：50ms CPU时间
- Pod总计：250ms CPU时间

**若节点总CPU时间为1000ms：**
- Pod CPU占比：250ms / 1000ms = 25%
- Pod功耗：25% × 活跃功耗

## 局限性与注意事项

### CPU归因适用场景

- **CPU密集型工作负载**且指令组合相似
- **稳态工作负载**无显著频率调整
- **相似工作负载类型间的相对比较**
- **长期趋势分析**

### 需谨慎场景

- **混合工作负载环境**中计算与I/O模式差异大
- **高性能计算**使用特殊指令集
- **基于Kepler指标的绝对功耗预算决策**
- **需要精确进程级测量的细粒度优化**

### 工作负载特性影响

#### 计算密集型 vs 内存密集型

```text
示例场景：
- 进程A：50% CPU，计算密集型（高频，持续执行）
- 进程B：50% CPU，内存密集型（频繁停滞，低频）

当前归因：两者获得相同功耗
实际情况：进程A可能多消耗2-3倍功耗
```

#### CPU电源状态影响

现代CPU的复杂电源管理会影响归因精度：

- **C状态（睡眠状态）**：不同休眠行为影响功耗
- **P状态（性能状态）**：动态频率调节影响每周期功耗
- **指令级差异**：向量指令比标量操作消耗更多功率

### 超越CPU归因

#### 内存与I/O考量

- **内存功耗**：内存密集型工作负载消耗更多DRAM能量
- **存储I/O**：触发存储控制器和设备功耗
- **网络I/O**：消耗网络接口和PCIe能量
- **GPU工作负载**：集成显卡功耗未被CPU指标捕获

## 关键指标

- `kepler_node_cpu_watts{}`：节点总功耗
- `kepler_process_cpu_watts{}`：单个进程功耗
- `kepler_container_cpu_watts{}`：容器级功耗
- `kepler_vm_cpu_watts{}`：虚拟机功耗
- `kepler_pod_cpu_watts{}`：Kubernetes Pod功耗

## 结论

Kepler的功耗归因系统提供了将硬件能耗按比例分配到个体工作负载的实用方法。虽然基于CPU时间的归因因现代CPU复杂性存在固有局限，但对于大多数监控和优化用例，它在准确性、简洁性和性能开销间取得了良好平衡。

理解Kepler功耗归因的能力边界和限制条件，有助于用户明智地运用这些指标进行决策。
```